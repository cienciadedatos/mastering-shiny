# Interfaz de Usuario Básica

```{r, include = FALSE}
source("_common.R")
source("demo.R")
```
**CAPÍTULO EN PROCESO DE TRADUCCIÓN**

## Introducción

Ahora que ya tienes una aplicación básica, podemos empezar a explorar los 
detalles que hacen que Shiny funcione. Como has visto en el capítulo anterior, 
Shiny anima a separar el código que genera tu interfaz de usuario (el front-end)
del código que dirige el comportamiento de tu aplicación (el back-end).

En este capítulo, nos centraremos en el front-end, y te daremos un tour 
relámpago por las entradas y salidas HTML que proporciona Shiny. Esto le da la 
capacidad de capturar muchos tipos de datos y mostrar muchos tipos de salida de  
R.Todavía no tiene muchas formas de unir las entradas y salidas, pero volveremos
a ello en el capítulo \@ref(action-layout).

Aquí me ceñiré principalmente a las entradas y salidas incorporadas en el propio
Shiny. Sin embargo, hay una rica y vibrante comunidad de paquetes de extensión, 
como [shinyWidgets](https://github.com/dreamRs/shinyWidgets), [colorpicker](https://github.com/daattali/colourpicker), y [
sorttable](https://rstudio.github.io/sortable/).
Puedes encontrar una lista completa y activamente mantenida de otros paquetes en <https://github.com/nanxstats/awesome-shiny-extensions>, mantenida por
[Nan Xiao](https://nanx.me/).

Como siempre, empezaremos cargando el paquete shiny:

```{r setup}
library(shiny)
```

## Entradas {#inputs}

Como vimos en el capítulo anterior, se utilizan funciones como `sliderInput()`,
`selectInput()`, `textInput()`, y `numericInput()` para insertar controles de 
entrada en la especificación de la IU. Ahora discutiremos la estructura común 
que subyace a todas las funciones de entrada y daremos una rápida visión general
de las entradas incorporadas en Shiny.

### Estructura común

Todas las funciones de entrada tienen el mismo primer argumento: `inputId`.
Este es el identificador utilizado para conectar el front-end con el back-end: 
si su UI tiene una entrada con el ID `"nombre", la función del servidor accederá
a ella con `input$nombre`.

El `inputId` tiene dos restricciones:

- Debe ser una cadena simple que contenga sólo letras, números y guiones bajos 
  (no se permiten espacios, guiones, puntos u otros caracteres especiales).
  Nómbralo como lo harías con una variable en R.

- Debe ser único. Si no es único, no tendrá forma de referirse a este control en
  la función de servidor.

La mayoría de las funciones de entrada tienen un segundo parámetro llamado 
`label`. Se utiliza para crear una etiqueta legible para el control. Shiny no 
impone ninguna restricción a esta cadena, pero tendrás que pensar cuidadosamente
en ella para asegurarte de que tu aplicación es utilizable por los humanos. El 
tercer parámetro suele ser `value`, que, cuando es posible, permite establecer
el valor por defecto. El resto de parámetros son exclusivos del control.

Al crear una entrada, recomiendo suministrar los argumentos `inputId` y `label`
por posición, y todos los demás argumentos por nombre:

```{r, results = FALSE}
sliderInput("min", "Límite (mínimo)", value = 50, min = 0, max = 100)
```

Las siguientes secciones describen las entradas incorporadas en Shiny, agrupadas
de forma imprecisa según el tipo de control que crean. El objetivo es darte una 
visión rápida de las opciones, no describir exhaustivamente todos los 
argumentos. A continuación mostraremos los parámetros más importantes de cada 
control, pero tendrás que leer la documentación para obtener todos los detalles.

### Texto libre

Recoge pequeñas cantidades de texto con `textInput()`, contraseñas con 
`passwordInput()`[^basic-ui-1], y párrafos de texto con `textAreaInput()`.

[^basic-ui-1]: Todo lo que hace `passwordInput()` es ocultar lo que el usuario 
está escribiendo, para que alguien que mire por encima de tu hombro no pueda 
leerlo. Depende de ti asegurarte de que las contraseñas no queden expuestas 
accidentalmente, por lo que no recomendamos el uso de contraseñas a menos que 
hayas recibido algún tipo de formación en programación segura.

```{r}
ui <- fluidPage(
  textInput("nombre", "¿Cuál es tu nombre?"),
  passwordInput("password", "¿Cuál es tu contraseña?"),
  textAreaInput("story", "Cuéntame sobre ti", rows = 3)
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/free-text", ui)
demo$takeScreenshot()
```

Si quieres asegurarte de que el texto tiene ciertas propiedades puedes utilizar 
`validate()`, a la que volveremos en el capítulo \@ref(action-feedback).

### Entradas numéricas

Para recoger valores numéricos, crea un cuadro de texto restringido con 
`numericInput()` o un deslizador con `sliderInput()`. Si proporcionas un vector 
numérico de longitud 2 para el valor por defecto de `sliderInput()`, obtendrá un
deslizador de "rango" con dos extremos.

```{r}
ui <- fluidPage(
  numericInput("num", "Número uno", valor = 0, min = 0, max = 100),
  sliderInput("num2", "Número dos", valor = 50, min = 0, max = 100),
  sliderInput("rng", "Rango", valor = c(10, 20), min = 0, max = 100)
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/numeric", ui)
demo$takeScreenshot()
```

En general, recomiendo utilizar los deslizadores sólo para rangos pequeños, o 
para casos en los que el valor preciso no es tan importante. Intentar 
seleccionar con precisión un número en un deslizador pequeño es un ejercicio de 
frustración.

Los deslizadores son extremadamente personalizables y hay muchas maneras de 
ajustar su apariencia. Consulte `?sliderInput` y 
<https://shiny.rstudio.com/articles/sliders.html> para más detalles.

### Fechas

Recoge un solo día con `dateInput()` o un rango de dos días con 
`dateRangeInput()`. Esto proporciona un cómodo selector de calendario, y 
argumentos adicionales como `datesdisabled` y `daysofweekdisabled` te permiten 
restringir el conjunto de entradas válidas.

```{r}
ui <- fluidPage(
  dateInput("dob", "¿Cuándo naciste?"),
  dateRangeInput("holiday", "¿Cuándo quieres tener tus próximas vacaciones?")
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/date", ui)
demo$takeScreenshot()
```

El formato de la fecha, el idioma y el día de inicio de la semana se ajustan por 
defecto a los estándares estadounidenses. Si está creando una aplicación con un 
público internacional, configura `formato`, `idioma` y `inicio de semana` para 
que las fechas sean naturales para sus usuarios.

### Opciones limitadas

Hay dos enfoques diferentes para permitir que el usuario elija entre un conjunto
preestablecido de opciones: `selectInput()` y `radioButtons()`.

```{r}
animals <- c("perro", "gato", "ratón", "pájaro", "otro", "odio a los animales")

ui <- fluidPage(
  selectInput("estado", "¿Cuál es tu estado favorito?", state.name),
  radioButtons("animal", "¿Cuál es tu animal favorito?", animales)
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/limited-choices", ui)
demo$takeScreenshot()
```

Los botones de radio tienen dos buenas características: muestran todas las 
opciones posibles, lo que los hace adecuados para listas cortas, y a través de 
los argumentos `choiceNames`/`choiceValues`, pueden mostrar opciones distintas 
al texto plano. El argumento `choiceNames` determina lo que se muestra al 
usuario; `choiceValues` determina lo que se devuelve en la función del servidor.

```{r}
ui <- fluidPage(
  radioButtons("rb", "Choose one:",
    choiceNames = list(
      icon("angry"),
      icon("smile"),
      icono("sad-tear")
    ),
    choiceValues = list("enfadado", "feliz", "triste")
  )
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/radio-icon", ui)
demo$takeScreenshot()
```

Los desplegables creados con `selectInput()` ocupan la misma cantidad de 
espacio, independientemente del número de opciones, lo que los hace más 
adecuados para opciones más largas. También puede establecer `multiple = TRUE` 
para permitir al usuario seleccionar múltiples elementos.

```{r}
ui <- fluidPage(
  selectInput(
    "state", "¿Cuál es tu estado favorito?", state.name,
    múltiple = TRUE
  )
)
```

```{r, echo = FALSE, out.width = NULL}
# No se puede automatizar fácilmente debido a los js desplegables
knitr::include_graphics("images/basic-ui/multi-select.png", dpi = 300)
```

Si tienes un conjunto muy grande de opciones posibles, puede querer usar 
`selectInput()` del lado del servidor para que el conjunto completo de opciones 
posibles no esté incrustado en la UI (lo que puede hacer que se cargue 
lentamente), sino que se envíe según lo necesite el servidor. Puedes aprender 
más sobre este tema avanzado en 
<https://shiny.rstudio.com/articles/selectize.html#server-side-selectize>.

No hay manera de seleccionar múltiples valores con los botones de radio, pero 
hay una alternativa que es conceptualmente similar: `checkboxGroupInput()`.

```{r}
ui <- fluidPage(
  checkboxGroupInput("animal", "¿Qué animales te gustan?", animals)
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/multi-radio", ui)
demo$takeScreenshot()
```

Si deseas una sola casilla de verificación para una sola pregunta de sí/no, 
utiliza `checkboxInput()`:

```{r}
ui <- fluidPage(
  checkboxInput("cleanup", "¿Limpiar?", valor = TRUE),
  checkboxInput("shutdown", "¿Cerrar?")
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/yes-no", ui)
demo$takeScreenshot()
```

### Subida de archivos

Permitir al usuario subir un archivo con `fileInput()`:

```{r}
ui <- fluidPage(
  fileInput("upload", NULL)
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/upload", ui)
demo$takeScreenshot()
```

``fileInput()`` requiere un manejo especial en el lado del servidor, y se 
discute en detalle en el capítulo `@ref(action-transfer).

### Botones de acción {#action-buttons}

Permite al usuario realizar una acción con `actionButton()` o `actionLink()`:

```{r}
ui <- fluidPage(
  actionButton("click", "¡Click me!"),
  actionButton("drink", "Drink me!", icon = icon("cocktail"))
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/action", ui)
demo$takeScreenshot()
```

Los enlaces y botones de las acciones se emparejan de forma más natural con 
`observeEvent()` o `eventReactive()` en su función de servidor. Todavía no has 
aprendido sobre estas importantes funciones, pero volveremos a ellas en la 
sección \@ref(control-timing-de-evaluación).

Puedes personalizar la apariencia usando el argumento `class` utilizando uno de 
los `"btn-primary"`, `"btn-success"`, `"btn-info"`, `"btn-warning"`, o 
`"btn-danger"`. También puedes cambiar el tamaño con `"btn-lg"`, `"btn-sm"` o 
`"btn-xs"`. Por último, puedes hacer que los botones ocupen todo el ancho del 
elemento en el que están incrustados con "btn-block".


```{r}
ui <- fluidPage(
  fluidRow(
    actionButton("click", "¡Clickéame!", class = "btn-danger"),
    actionButton("drink", "¡Bébeme!", class = "btn-lg btn-success")
  ),
  fluidRow(
    actionButton("eat", "¡Cómeme!", class = "btn-block")
  )
)
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/action-css", ui)
demo$takeScreenshot()
```

El argumento `class` funciona estableciendo el atributo `class` del HTML 
subyacente, que afecta al estilo del elemento. Para ver otras opciones, puedes 
leer la documentación de Bootstrap, el sistema de diseño CSS utilizado por 
Shiny: 
[\<http://bootstrapdocs.com/v3.3.6/docs/css/\#buttons\>](http://bootstrapdocs.com/v3.3.6/docs/css/#buttons){.uri}.

### Ejercicios

1.  Cuando el espacio es escaso, es útil etiquetar las cajas de texto usando un 
    marcador de posición que aparece *dentro* del área de entrada de texto.
    ¿Cómo se llama a `textInput()` para generar el UI de abajo?

    ```{r, echo = FALSE, out.width = NULL, message = FALSE}
    ui <- fluidPage(
      textInput("name", NULL, placeholder = "Your name")
    )
    demo <- demoApp$new("basic-ui/placeholder", ui)
    demo$takeScreenshot()
    ```

2.  Lee detenidamente la documentación de `sliderInput()` para saber cómo crear 
    un deslizador de fecha, como se muestra a continuación.

    ```{r, echo = FALSE, out.width = NULL, message = FALSE}
    today <- as.Date("2021-01-01")
    ui <- fluidPage(
      sliderInput("delivery", "When should we deliver?", 
        value = today + 1, 
        min = today, 
        max = today + 7, 
        step = 1, 
        round = TRUE
      )
    )
    demo <- demoApp$new("basic-ui/date-slider", ui)
    demo$takeScreenshot()
    ```

3.  Crea una entrada deslizante para seleccionar valores entre 0 y 100 donde el 
    intervalo entre cada valor seleccionable en el deslizador sea de 5. A 
    continuación, añade una animación al widget de entrada para que cuando el 
    usuario pulse el play el widget de entrada se desplace por el rango 
    automáticamente.

4.  Si tienes una lista moderadamente larga en un `selectInput()`, es útil 
    crear sub-encabezados que dividan la lista en partes. Lea la documentación 
    para saber cómo hacerlo. (Pista: el HTML subyacente se llama `<optgroup>`).

## Salidas {#outputs}

Las salidas en la UI crean marcadores de posición que luego son llenados por la 
función del servidor. Al igual que las entradas, las salidas toman un único ID 
como primer argumento [^basic-ui-2]: si tu especificación de la UI crea una 
salida con el ID `"plot", accederás a ella en la función del servidor con 
`output$plot`.

[^basic-ui-2]: Tenga en cuenta que el nombre de ese argumento es diferente para 
las entradas (`inputId`) y las salidas (`outputId`). No uso el nombre del primer
argumento porque es muy importante y espero que recuerdes lo que hace sin una 
pista adicional.

Cada función `output` en el front end está acoplada a una función `render` en el
back end. Hay tres tipos principales de salida, que corresponden a las tres 
cosas que normalmente se incluyen en un informe: texto, tablas y gráficos. Las 
siguientes secciones muestran los fundamentos de las funciones de salida en el 
front-end, junto con las correspondientes funciones `render` en el back-end.

### Text

Output regular text with `textOutput()` and fixed code and console output with `verbatimTextOutput()`.

```{r}
ui <- fluidPage(
  textOutput("text"),
  verbatimTextOutput("code")
)
server <- function(input, output, session) {
  output$text <- renderText({ 
    "Hello friend!" 
  })
  output$code <- renderPrint({ 
    summary(1:10) 
  })
}
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/output-text", ui, server)
demo$takeScreenshot()
```

Note that the `{}` are only required in render functions if need to run multiple lines of code.
As you'll learn shortly, you should do as little computation in your render functions as possible, which means you can often omit them.
Here's what the server function above would look like if written more compactly::

```{r}
server <- function(input, output, session) {
  output$text <- renderText("Hello friend!")
  output$code <- renderPrint(summary(1:10))
}
```

Note that there are two render functions which behave slightly differently:

-   `renderText()` combines the result into a single string, and is usually paired with `textOutput()`
-   `renderPrint()` *prints* the result, as if you were in an R console, and is usually paired with `verbatimTextOutput()`.

We can see the difference with a toy app:

```{r}
ui <- fluidPage(
  textOutput("text"),
  verbatimTextOutput("print")
)
server <- function(input, output, session) {
  output$text <- renderText("hello!")
  output$print <- renderPrint("hello!")
}
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/text-vs-print", ui, server)
demo$takeScreenshot()
```

This is equivalent to the difference between `cat()` and `print()` in base R.

### Tables

There are two options for displaying data frames in tables:

-   `tableOutput()` and `renderTable()` render a static table of data, showing all the data at once.

-   `dataTableOutput()` and `renderDataTable()` render a dynamic table, showing a fixed number of rows along with controls to change which rows are visible.

`tableOutput()` is most useful for small, fixed summaries (e.g. model coefficients); `dataTableOutput()` is most appropriate if you want to expose a complete data frame to the user.
If you want greater control over the output of `dataTableOutput()`, I highly recommend the [reactable](https://glin.github.io/reactable/index.html) package by Greg Lin.

```{r}
ui <- fluidPage(
  tableOutput("static"),
  dataTableOutput("dynamic")
)
server <- function(input, output, session) {
  output$static <- renderTable(head(mtcars))
  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))
}
```

```{r, echo = FALSE, out.width = "100%", message = FALSE}
demo <- demoApp$new("basic-ui/output-table", ui, server)
demo$resize(width = 800)
demo$takeScreenshot()
```

### Plots

You can display any type of R graphic (base, ggplot2, or otherwise) with `plotOutput()` and `renderPlot()`:

```{r}
ui <- fluidPage(
  plotOutput("plot", width = "400px")
)
server <- function(input, output, session) {
  output$plot <- renderPlot(plot(1:5), res = 96)
}
```

```{r, echo = FALSE, out.width = NULL, message = FALSE}
demo <- demoApp$new("basic-ui/output-plot", ui, server)
demo$takeScreenshot()
```

By default, `plotOutput()` will take up the full width of its container (more on that shortly), and will be 400 pixels high.
You can override these defaults with the `height` and `width` arguments.
We recommend always setting `res = 96` as that will make your Shiny plots match what you see in RStudio as closely as possible.

Plots are special because they are outputs that can also act as inputs.
`plotOutput()` has a number of arguments like `click`, `dblclick`, and `hover`.
If you pass these a string, like `click = "plot_click"`, they'll create a reactive input (`input$plot_click`) that you can use to handle user interaction on the plot, e.g. clicking on the plot.
We'll come back to interactive plots in Shiny in Chapter \@ref(action-graphics).

### Downloads

You can let the user download a file with `downloadButton()` or `downloadLink()`.
These require new techniques in the server function, so we'll come back to that in Chapter \@ref(action-transfer).

### Exercises

1.  Which of `textOutput()` and `verbatimTextOutput()` should each of the following render functions be paired with?

    a.  `renderPrint(summary(mtcars))`

    b.  `renderText("Good morning!")`

    c.  `renderPrint(t.test(1:5, 2:6))`

    d.  `renderText(str(lm(mpg ~ wt, data = mtcars)))`

2.  Re-create the Shiny app from Section \@ref(plots), this time setting height to 300px and width to 700px.
    Set the plot "alt" text so that a visually impaired user can tell that its a scatterplot of five random numbers.

3.  Update the options in the call to `renderDataTable()` below so that the data is displayed, but all other controls are suppress (i.e. remove the search, ordering, and filtering commands).
    You'll need to read `?renderDataTable` and review the options at <https://datatables.net/reference/option/>.

    ```{r}
    ui <- fluidPage(
      dataTableOutput("table")
    )
    server <- function(input, output, session) {
      output$table <- renderDataTable(mtcars, options = list(pageLength = 5))
    }
    ```

4.  Alternatively, read up on [reactable](https://glin.github.io/reactable), and convert the above app to use it instead.

## Summary

This chapter has introduced you to the major input and output functions that make up the front end of a Shiny app.
This was a big info dump, so don't expect to remember everything after a single read.
Instead, come back to this chapter when you're looking for a specific component: you can quickly scan the figures, and then find the code you need.

In the next chapter, we'll move on to the back end of a Shiny app: the R code that makes your user interface come to life.
